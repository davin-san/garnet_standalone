/*
 * Copyright (c) 2008 Princeton University
 * Copyright (c) 2016 Georgia Institute of Technology
 * All rights reserved.
 *
 * ... (copyright header) ...
 */


#include "RoutingUnit.hh"

#include "InputUnit.hh"
#include "Router.hh"
#include "NetDest.hh"
#include "GarnetNetwork.hh"

#include <cstdlib>
#include <algorithm>

namespace garnet
{

RoutingUnit::RoutingUnit(Router *router)
{
    m_router = router;
    m_routing_table.clear();
    m_weight_table.clear();
}

void
RoutingUnit::addRoute(std::vector<NetDest>& routing_table_entry)
{
    if (routing_table_entry.size() > m_routing_table.size()) {
        m_routing_table.resize(routing_table_entry.size());
    }
    for (int v = 0; v < (int)routing_table_entry.size(); v++) {
        m_routing_table[v].push_back(routing_table_entry[v]);
    }
}

void
RoutingUnit::addWeight(int link_weight)
{
    m_weight_table.push_back(link_weight);
}

void
RoutingUnit::addRouteForPort(int port, int dest_ni)
{
    int num_vnets = m_router->get_num_vnets();
    if ((int)m_routing_table.size() < num_vnets) {
        m_routing_table.resize(num_vnets);
    }

    for (int v = 0; v < num_vnets; v++) {
        if ((int)m_routing_table[v].size() <= port) {
            m_routing_table[v].resize(port + 1);
        }
        m_routing_table[v][port].add(dest_ni);
    }
    
    if ((int)m_weight_table.size() <= port) {
        m_weight_table.resize(port + 1, 1);
    }
}

bool
RoutingUnit::supportsVnet(int vnet, std::vector<int> sVnets)
{
    if (sVnets.size() == 0) return true;
    if (std::find(sVnets.begin(), sVnets.end(), vnet) != sVnets.end()) return true;
    return false;
}

int
RoutingUnit::lookupRoutingTable(int vnet, const NetDest& msg_destination)
{
    int min_weight = -1; 
    std::vector<int> output_link_candidates;

    if (vnet >= (int)m_routing_table.size()) return -1;

    for (int link = 0; link < (int)m_routing_table[vnet].size(); link++) {
        if (msg_destination.intersectionIsNotEmpty(m_routing_table[vnet][link])) {
            int weight = 1;
            if (link < (int)m_weight_table.size()) weight = m_weight_table[link];
            if (weight <= min_weight || min_weight == -1) min_weight = weight;
        }
    }

    for (int link = 0; link < (int)m_routing_table[vnet].size(); link++) {
        if (msg_destination.intersectionIsNotEmpty(m_routing_table[vnet][link])) {
            int weight = 1;
            if (link < (int)m_weight_table.size()) weight = m_weight_table[link];
            if (weight == min_weight) output_link_candidates.push_back(link);
        }
    }

    if (m_router->get_net_ptr()->getDebug()) {
        std::cout << "DEBUG: Router " << m_router->get_id() << " lookup dest=";
        msg_destination.print();
        std::cout << " found " << output_link_candidates.size() << " candidates. Selected port " << (output_link_candidates.size() > 0 ? std::to_string(output_link_candidates[0]) : "NONE") << std::endl;
    }

    if (output_link_candidates.size() == 0) return -1;
    return output_link_candidates.at(0);
}


void
RoutingUnit::addInDirection(PortDirection inport_dirn, int inport_idx)
{
    m_inports_dirn2idx[inport_dirn] = inport_idx;
    m_inports_idx2dirn[inport_idx]  = inport_dirn;
}

void
RoutingUnit::addOutDirection(PortDirection outport_dirn, int outport_idx)
{
    m_outports_dirn2idx[outport_dirn] = outport_idx;
    m_outports_idx2dirn[outport_idx]  = outport_dirn;
}

int
RoutingUnit::outportCompute(RouteInfo route, int inport,
                            PortDirection inport_dirn)
{
    // Standalone: Always use the routing table generated by conf_generator.py (Dijkstra)
    // This supports Mesh, Crossbar, Pt2Pt and any other gem5 topology automatically.
    return lookupRoutingTable(route.vnet, *(route.net_dest));
}

int
RoutingUnit::outportComputeXY(RouteInfo route,
                              int inport,
                              PortDirection inport_dirn)
{
    return lookupRoutingTable(route.vnet, *(route.net_dest));
}

int
RoutingUnit::outportComputeCustom(RouteInfo route,
                                 int inport,
                                 PortDirection inport_dirn)
{
    return -1;
}

} // namespace garnet
